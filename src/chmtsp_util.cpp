/**
 * @file chmtsp_util.cpp
 * @brief Implements functions for finding initial heuristic solution
 * for the mTSPBC using the convex hull heuristics.
 * @details This file contains functions and variables related
 * to computing and plotting initial heuristics solution.
 */

#include "chmtsp_util.hpp"
#include "MTSPBC_util.hpp"
#include <algorithm>
#include <cstddef>
#include <cstdint>
#include <sstream>
#include <stdexcept>
#include <utility>
#include <vector>
#include <string>
#include <fstream>
#include <iostream>
#include <cmath>


std::vector<size_t> unassigned_nodes;       // vetor de nós não assinalados
uint32_t n_nodes;                                // número de nós
uint32_t k_vehicles;                             // número de veículos
uint32_t r_radius;                               // raio de cobertura
std::vector<Coord> coordinates;             // coordenadas dos nós
std::vector<std::vector<uint32_t>> matriz_dist;  // matriz de adjacencias
std::vector<std::vector<std::vector<double>>> LB;  // lower bound time covering node
std::vector<std::vector<std::vector<double>>> UB;  // upper bound time covering node



/**
 * @brief Read the instance file in BCLIB format.
 * @param file_name String that contains the file path of the instance.
 * @return Returns 0 if the file was read and parameters retrieved.
 */
uint32_t read_instance(std::string file_name, std::vector<Coord>& coord) {
    // create fstream object from file name string
    std::ifstream input_instance(file_name);
    bool parameters_read {false};

    // checks if it was open
    if(!input_instance.is_open()) {
        throw std::runtime_error("error: could not open file");
    }

    std::string line;                   // string para ler as linhas
    while (std::getline(input_instance, line)) {
        if (line.empty() || line[0] == '#') {
            continue;
        }

        std::stringstream ss(line);     // stream para ler os valores separados por espaços

        if (!parameters_read) {
            ss >> k_vehicles >> n_nodes >> r_radius;
            n_nodes++;                  // adiciona garagem ao número de nós
            matriz_dist.resize(n_nodes, std::vector<uint32_t>(n_nodes));     // aloca matriz de distancias
            for (uint32_t i{}; i < n_nodes; i++) {
                unassigned_nodes.push_back(i);                          // coloca todos os nós como não assinalados
            }
            parameters_read = true;
        } else {
            Coord new_coord;
            ss >> new_coord.pos_x >> new_coord.pos_y;
            coord.push_back(new_coord);
        }
    }
    input_instance.close();
    return unassigned_nodes.size();
}


/**
 * @brief Read the instance file generated by the pre-processor with distance information.
 * @param input_file String that contains the file path of the instance.
 * @return Returns 0 if the file was read and parameters retrieved.
 */
std::vector<std::vector<uint32_t>> read_inst_dist(std::string input_file) {

    // create fstream file object from file name string
    std::ifstream input_instance(input_file);

    // checks if the file was open
    if (!input_instance.is_open()) {
        throw std::runtime_error("error: cannot open file");
    }

    bool parameters_read {false};
    std::string line;

    while (std::getline(input_instance, line)) {
        if (line.empty() || line[0] == '#') {
            continue;
        }

        std::stringstream ss(line);     // stream para ler os valores separados por espaços

        if(!parameters_read) {
            parameters_read = true;
        } else {
            size_t i{};
            size_t j{};
            uint32_t dist{};
            ss >> i >> j >> dist;
            matriz_dist[i][j] = dist;   // le matriz de distancias
        }

    }

    return matriz_dist;
}


/**
 * @brief Read the instance file generated by the pre-processor with cover information. It populates
 * LB and UB vectors. For index i,j,k, LB[i][j][k] and UB[i][j][k] it stores if a vehicle
 * travesing from i to j covers k at time between LB <= UB.
 * @param input_file String that contains the file path of the instance.
 * @return Returns 0 if the file was read and parameters retrieved.
 */
uint32_t read_cover(std::string cover_file){
    // open cover.dat file
    std::ifstream cover_f(cover_file);
    // checks if the file was open
    if (!cover_f.is_open()) {
        std::cerr << "error loading cover file!" << std::endl;
        return 1;
    }
    // variable to store the current read line
    std::string line;
    // resize lower and upper bound variable
    LB.resize(n_nodes);
    UB.resize(n_nodes);
    for (uint32_t i{}; i < n_nodes; i++) {
        LB[i].resize(n_nodes);
        UB[i].resize(n_nodes);
        for (uint32_t j{}; j < n_nodes; j++) {
            LB[i][j].resize(n_nodes);
            UB[i][j].resize(n_nodes);
        }
    }
    // read and process line by line
    while (std::getline(cover_f, line)) {
        if (line.empty()) {
            continue;
        }
        std::stringstream ss(line);
        size_t i{}, j{}, k{};
        double lb_tmp{}, ub_tmp{};
        ss >> i >> j >> k >> lb_tmp >> ub_tmp;
        LB[i][j][k] = lb_tmp;
        UB[i][j][k] = ub_tmp;
    }
    return 0;
}


/**
 * @brief Checks if a vehicle traversing from i do j covers k.
 * @param i The departing node for the traversing vehicle.
 * @param j The arrival node for the traversing vehicle.
 * @param k The node under cover assumption.
 * @return true if k is covered, else false.
 */
bool covers_node(size_t i, size_t j, size_t k) {
    if (LB[i][j][k] <= UB[i][j][k]) {
        return true;
    }
    else {
        return false;
    }
}


/**
 * @brief From three coordinates, compute if they are in clockwise or counterclockwire order.
 * @param a Coordinate of the first node.
 * @param b Coordinate of the second node.
 * @param c Coordinate of the third node.
 * @return Negative value if clockwise and positive value if counterclockwise. Zero if collinear.
 */
// int orientation(Coord a, Coord b, Coord c) {
//     long long area = (b.pos_x - a.pos_x)*(c.pos_y - a.pos_y) - (c.pos_x - a.pos_x)*(b.pos_y - a.pos_y);
//     if (area < 0) {
//         return -1; // cw
//     } else if (area > 0) {
//         return 1; // ccw
//     }
//     return 0;
// }


/**
 * @brief Compute the rounded integer distance of two nodes using L2 norm.
 * @param a First node.
 * @param b Second node.
 * @return The integer distance of a and b.
 */
// uint32_t distance(const Nodes& a, const Nodes& b) {
//     double dx = a.pos.pos_x - b.pos.pos_x;
//     double dy = a.pos.pos_y - b.pos.pos_y;
//     double result = std::sqrt(std::pow(dx, 2) + std::pow(dy, 2));
//     return std::round(result);
// }

// uint32_t distance(const Coord& a, const Coord& b) {
//     double dx = a.pos_x - b.pos_x;
//     double dy = a.pos_y - b.pos_y;
//     double result = std::sqrt(std::pow(dx, 2) + std::pow(dy, 2));
//     return std::round(result);
// }

/**
 * @brief Saves data files for plotting.
 * @param hull_indices The indices of the route.
 * @return Returns 0 if the data was succesfully saved.
 */
uint32_t save_data(const std::vector<std::vector<uint32_t>>& onion_hull) {
    std::ofstream points_file("points.dat");
    for (const auto& coord : coordinates) {
        points_file << coord.pos_x << " " << coord.pos_y << "\n";
    }
    points_file.close();

    std::ofstream hull_file("hull.dat");
    for (auto h : onion_hull) {
        for (uint32_t idx : h) {
            hull_file << coordinates[idx].pos_x << " " << coordinates[idx].pos_y << "\n";
        }
        hull_file << coordinates[h[0]].pos_x << " " << coordinates[h[0]].pos_y << "\n";
        hull_file << std::endl << std::endl;
    }

    // Close the hull
    hull_file.close();
    return 0;
}

uint32_t save_data(const std::vector<uint32_t>& h, const std::string& hull_file_path) {

    std::ofstream hull_file(hull_file_path);
    for (uint32_t idx : h) {
        hull_file << coordinates[idx].pos_x << " " << coordinates[idx].pos_y << "\n";
    }
    hull_file << coordinates[h[0]].pos_x << " " << coordinates[h[0]].pos_y << "\n";
    hull_file << std::endl << std::endl;

    // Close the hull
    hull_file.close();
    return 0;
}

/**
 * @brief Find the convex hull using the Grahan Scan Algorithm.
 * @return Returns a vector that has the nodes index forming a hull route.
 */
std::vector<uint32_t> find_initial_hull() {
    // Find the leftmost unassigned node
    size_t point_left_most_i = unassigned_nodes[0];
    for (size_t idx = 1; idx < unassigned_nodes.size(); idx++) {
        Coord left_most_coord = coordinates[point_left_most_i];
        Coord current_point = coordinates[unassigned_nodes[idx]];
        if (current_point.pos_x < left_most_coord.pos_x ||
            (current_point.pos_x == left_most_coord.pos_x &&
             current_point.pos_y < left_most_coord.pos_y)) {
            point_left_most_i = unassigned_nodes[idx];
        }
    }

    // Build vector of Nodes for unassigned nodes (excluding leftmost)
    std::vector<Nodes> nodes;
    Nodes point_left_most;
    point_left_most.index = point_left_most_i;
    point_left_most.pos = coordinates[point_left_most_i];
    for (size_t i = 0; i < unassigned_nodes.size(); i++) {
        size_t idx = unassigned_nodes[i];
        if (idx != point_left_most_i) {
            Nodes n;
            n.index = idx;
            n.pos = coordinates[idx];
            nodes.push_back(n);
        }
    }

    // Sort nodes by polar angle with respect to leftmost point
    std::sort(nodes.begin(), nodes.end(), [&point_left_most](const Nodes& a, const Nodes& b) {
        int d = orientation(point_left_most.pos, a.pos, b.pos);
        if (d > 0) return true;
        if (d < 0) return false;
        // Collinear: closer one first
        return distance(point_left_most, a) < distance(point_left_most, b);
    });

    // Graham scan
    std::vector<Nodes> stack;
    stack.push_back(point_left_most);
    if (!nodes.empty()) stack.push_back(nodes[0]);
    for (size_t i = 1; i < nodes.size(); i++) {
        while (stack.size() > 1 &&
               orientation(stack[stack.size()-2].pos, stack[stack.size()-1].pos, nodes[i].pos) <= 0) {
            stack.pop_back();
        }
        stack.push_back(nodes[i]);
    }

    // Return the indices of the hull
    std::vector<uint32_t> hull_indices;
    for (const auto& n : stack) {
        hull_indices.push_back(static_cast<int>(n.index));
    }
    return hull_indices;
}


/**
 * @brief Find one hull for every vehicle using Granhan Scan Algorithm.
 * @return A vector with one route for every vehicle.
 */
std::vector<std::vector<uint32_t>> find_onion_hull() {

    // declara vetor de rotas
    std::vector<std::vector<uint32_t>> onion_hull;

    // iterativamente, encontra uma rota para cada veículo
    for (uint32_t i{0}; i < k_vehicles; i++) {
        std::vector<uint32_t> initial_hull { find_initial_hull() };
        std::vector<uint32_t> clean_hull { remove_covered_nodes(initial_hull) };
        onion_hull.push_back(clean_hull);
    }

    return onion_hull;
}


/**
 * @brief Removes the nodes that are covered by the remaining route.
 * @param hull The initial hull.
 * @return The remaining hull after removing the spare nodes, or the same hull if
 * none were removed.
 */
std::vector<uint32_t> remove_covered_nodes(std::vector<uint32_t> hull) {
    // three nodes to check cover, m=m, n=m+1, o=m+2
    // if a vehicle travelling from m to o covers n, remove if from hull
    size_t m{ 0 }, n{ 1 }, o{ 2 };
    // checks covering in round-robin
    bool round_robin { true };
    // loop, does not let the hull have less than 3
    while (round_robin) {
        bool removed { false };
        while (o < hull.size()) {
            if (hull.size() == 3) {
                unassign(hull);
                return hull;
            }
            bool does_it_cover = covers_node(hull[m], hull[o], hull[n]);
            if (does_it_cover) {
                hull.erase(hull.begin() + n);
                removed = true;
            }
            else {
                m++; n++; o++;
                removed |= false;
            }
        }
        if (round_robin || removed) {
            if (hull.size() == 3) {
                unassign(hull);
                return hull;
            }

            bool does_it_cover = covers_node(hull.back(), hull[1], hull.front());
            if (does_it_cover) {
                hull.erase(hull.begin());
                round_robin = true;
            }
            else {
                round_robin = false;
            }
            if (hull.size() == 3){
                unassign(hull);
                return hull;
            }
            does_it_cover = covers_node(hull.back() - 1, hull.front(), hull.back());
            if (does_it_cover) {
                hull.pop_back();
                round_robin = true;
            }
            else {
                round_robin = false;
            }
        }
    }
    unassign(hull);
    return hull;
}


/**
 * @brief Prints the hull (vector of integer indexes) in inserted order.
 * @param hull The hull to be printed.
 * @return Nothing
 */
void print_hull(std::vector<uint32_t> hull) {
    for (const auto& i : hull) {
        std::cout << i << " ";
    }
    std::cout << std::endl;
}


/**
 * @brief Erases the assigned nodes from the unassigned vector of nodes.
 * @param hull A hull with assigned nodes
 * @return The number of removed nodes.
 */
uint32_t unassign(const std::vector<uint32_t>& hull) {
    int n_removed {};
    for (auto i : hull) {
        for (uint32_t j{}; j < unassigned_nodes.size(); j++) {
            if (i == unassigned_nodes[j]) {
                unassigned_nodes.erase(unassigned_nodes.begin() + j);
                n_removed++;
                break;
            }
        }
    }
    return n_removed;
}


/**
 * @brief Adds the remaining non assigned nodes to the generated hulls. Follows the
 * cheapest insertion heuristic, inserting the node at the position that increases the least
 * objective amount.
 * @param onion_hull The vector of hulls.
 * @return The vector of routes, representing a solution.
 */
std::vector<std::vector<uint32_t>> cheapest_insertion(std::vector<std::vector<uint32_t>> onion_hull) {
    while(unassigned_nodes.size() > 0) {
        uint32_t k_index {};
        uint32_t position {};
        uint32_t new_cost { 999999 };
        uint32_t unassigned_index {};
        for (auto un { 0 }; un < unassigned_nodes.size(); un++) {
            for (auto k{ 0 }; k < onion_hull.size(); k++) {
                for (auto i{ 0 }; i < onion_hull[k].size(); i++) {
                    std::vector<uint32_t> insertion_hull { onion_hull[k] };
                    insertion_hull.insert(insertion_hull.begin() + i, unassigned_nodes[un]);
                    uint32_t temp_cost { hull_objective(insertion_hull) };
                    if (temp_cost < new_cost) {
                        position = i;
                        k_index = k;
                        new_cost = temp_cost;
                        unassigned_index = un;
                    }
                }
            }
        }
        onion_hull[k_index].insert(onion_hull[k_index].begin() + position, unassigned_nodes[unassigned_index]);
        unassign(onion_hull[k_index]);
        if (unassigned_index >= unassigned_nodes.size()) {
            unassigned_index = 0;
        }
    }
    return onion_hull;
}


/**
 * @brief Adds the depot to every route.
 * @param onion_hull The vector of incomplete routes, one for every vehicle.
 * @return The vector of routes representing a complete solution.
 */
std::vector<std::vector<uint32_t>> assign_depot(std::vector<std::vector<uint32_t>> onion_hull) {
    uint32_t vehicle_at_depot { 0 };
    if (!unassigned_nodes.empty()) {
        if(unassigned_nodes[0] != 0) {
            for (auto h{0}; h < k_vehicles; h++) {
                for (auto i : onion_hull[h]) {
                    if (i == 0) {
                        vehicle_at_depot = h;
                    }
                }
            }
        }
    }
    for (uint32_t k{}; k < onion_hull.size(); k++) {
        if (k == vehicle_at_depot) {
            continue;
        }
        uint32_t new_cost{ 999999 };
        uint32_t position{};
        for (uint32_t i{ 0 }; i < onion_hull[k].size(); i++) {
            std::vector<uint32_t> insertion_hull { onion_hull[k] };
            insertion_hull.insert(insertion_hull.begin() + i, 0);
            uint32_t temp_cost { hull_objective(insertion_hull) };
            if (temp_cost < new_cost) {
                position = i;
                new_cost = temp_cost;
            }
        }
        onion_hull[k].insert(onion_hull[k].begin() + position, 0);
    }
    if (!unassigned_nodes.empty())
        if (unassigned_nodes[0] == 0)
            unassigned_nodes.erase(unassigned_nodes.begin());
    return onion_hull;
}


/**
 * @brief Computer the objective of a route.
 * @param hull The vector of the indexes representing a route.
 * @return The objective of the route.
 */
uint32_t hull_objective(const std::vector<uint32_t>& hull) {
    uint32_t objective{};
    for (uint32_t i{ 1 }; i < hull.size(); i++) {
        uint32_t j { i - 1 };
        objective += matriz_dist[hull[j]][hull[i]];
    }
    objective += matriz_dist[hull.back()][hull.front()];
    return objective;
}

uint32_t get_vehicle_node_index(const std::vector<uint32_t>& route, uint32_t time) {
    bool started_route{ false };
    uint32_t last_node { 0 };
    uint32_t current_node { 0 };
    uint32_t current_time { 0 };
    for (auto i { 0 }; i < route.size(); i++) {
        if (!started_route) {
            started_route = true;
            continue;
        }
        current_node = i;
        current_time += matriz_dist[route[i]][route[last_node]];
        if (current_time >= time) return i;
        last_node = current_node;
    }
    return last_node;
}


Coord get_real_position(uint32_t time, std::vector<uint32_t> route) {
    bool started_route { false };
    double current_time {};
    uint32_t last_node { 0 };
    uint32_t current_node { 0 };
    uint32_t time_next_node {};
    uint32_t time_last_node {};
    for (auto i : route) {
        if (!started_route) {
            started_route = true;
            continue;
        }
        else {
            current_node = i;
            time_next_node += matriz_dist[current_node][last_node];
            if (time_next_node > time) break;
            time_last_node = time_next_node;
            last_node = current_node;
        }
    }
    if (time_next_node < time) return coordinates[0];
    uint32_t diff_time = time - time_last_node;
    double curr_x { coordinates[current_node].pos_x };
    double curr_y { coordinates[current_node].pos_y };
    double last_x { coordinates[last_node].pos_x };
    double last_y { coordinates[last_node].pos_y };
    double x_vec { curr_x - last_x };
    double y_vec { curr_y - last_y };
    double vec_norm { std::sqrt(std::pow(x_vec, 2) + std::pow(y_vec, 2)) };
    double x_vec_unit { x_vec / vec_norm };
    double y_vec_unit { y_vec / vec_norm };
    Coord real_coord {};
    real_coord.pos_x = last_x + diff_time * x_vec_unit;
    real_coord.pos_y = last_y + diff_time * y_vec_unit;
    return real_coord;
}


bool check_feasibility(const std::vector<std::vector<uint32_t>>& onion_hull) {
    std::vector<uint32_t> travel_time(k_vehicles);           // travel time for every vehicle
    std::vector<std::pair<uint32_t, uint32_t>> events;            // events: `k` vehicle reaches a node at `t` time
    bool is_feasible { false };
    for (auto h { 0 }; h < onion_hull.size(); h++) {
        uint32_t last_node { 0 };
        bool started_tour { false };
        for (auto i { 0 }; i < onion_hull[h].size(); i++) {
            if (last_node == 0 && !started_tour) {
                started_tour = true;
                continue;
            }
            else {
                uint32_t current_node = onion_hull[h][i];
                travel_time[h] += matriz_dist[current_node][last_node];
                last_node = current_node;
                events.push_back(std::make_pair(travel_time[h], h));
            }
        }
    }
    std::sort(events.begin(), events.end());
    for (auto e : events) {
        uint32_t e_time { e.first };
        uint32_t e_vehicle { e.second };
        for (auto i { 0 }; i < k_vehicles; i++) {
            if (e.second == i) continue;
            Coord real_i_pos { get_real_position(e_time, onion_hull[i]) };
            uint32_t event_node_index { get_vehicle_node_index(onion_hull[e_vehicle], e_time) };
            Coord e_coord { coordinates[onion_hull[e_vehicle][event_node_index]] };
            uint32_t distance_cov { distance(e_coord, real_i_pos) };
            if (distance_cov > r_radius) return false;
        }
    }
    return true;
}


std::vector<std::vector<uint32_t>> fix_initial_route(std::vector<std::vector<uint32_t>> onion_hull) {
    for (auto i{ 0 }; i < onion_hull.size(); i++) {
        std::vector<uint32_t> fixed_route;
        auto it = std::find(onion_hull[i].begin(), onion_hull[i].end(), 0);
        std::rotate(onion_hull[i].begin(), it, onion_hull[i].end());
        onion_hull[i].push_back(0);
    }
    return onion_hull;
}
